# 高级编程



## 📅 Day 1 - 初识面向对象

### 1. 编程范式

- **面向过程 (POP)**：以过程为核心，强调解决问题的步骤，将步骤封装成函数。关注“怎么做”。
- **面向对象 (OOP)**：以对象为核心，对象由**属性**（特征）和**方法**（行为）构成。关注“谁来做”。
- **关系**：面向对象从整体分析，底层实现仍需面向过程，两者相辅相成。

### 2. 类与对象

- **类 (Class)**：抽象的概念，如“鸟类”。包含属性（变量）和方法（函数）。

- **对象 (Object)**：类的具体实例（个体）。

- **定义语法**：

  Python

  ```
  class 类名: # 首字母大写（大驼峰）
      def __init__(self, name): # 构造方法，初始化属性
          self.name = name
  ```

- **self**：代表类的**实例对象**本身。

------

## 📅 Day 2 & 3 - 面向对象三大特征

### 1. 封装 (Encapsulation)

- **隐藏属性/方法**：在名称前加双下划线 `__` 实现（如 `self.__money`）。本质是名称修改（`_类名__属性名`）。
- **property 装饰器**：
  - `@property`：获取属性。
  - `@方法名.setter`：设置属性（可进行校验）。

### 2. 继承 (Inheritance)

- **语法**：`class 子类(父类):`。Python 所有类默认继承 `object`。
- **方法重写**：子类定义与父类同名的方法以覆盖父类行为。
- **super()**：用于在子类中调用父类的方法或初始化父类属性。
- **查找顺序**：对象 -> 类 -> 父类（遵循 `__mro__` 顺序）。

### 3. 多态 (Polymorphism)

- **定义**：同一套方法在不同子类对象上具有不同的表现形式。
- **实现**：必须有继承且子类重写父类方法。

------

## 📅 Day 4 & 5 - 反射、异常与内置方法

### 1. 反射

通过字符串形式操作对象的属性和方法：

- `getattr(obj, name)`：获取。
- `hasattr(obj, name)`：检查是否存在。
- `setattr(obj, name, val)`：设置。
- `delattr(obj, name)`：删除。

### 2. 异常处理

- **机制**：`try...except...else...finally`。
- **断言**：`assert 条件, 提示信息`。条件为假时报错。
- **主动抛出**：`raise 异常类('错误信息')`。

### 3. 内置魔法方法

- `__str__`：控制 `print(对象)` 时的输出内容。
- `__new__`：构造方法，负责开辟内存空间，在 `__init__` 之前执行。
- `__del__`：析构方法，对象被销毁前自动调用。

------

## 📅 Day 6 - 11 MySQL 数据库

### 1. 核心概念与 SQL 指令

- **类型**：关系型（MySQL, Oracle）与非关系型（Redis, MongoDB）。
- **SQL 分类**：DDL（定义表结构）、DML（增删改数据）、DQL（查询数据）。

### 2. 常用操作

- **约束**：`primary key`（主键）、`not null`（非空）、`unique`（唯一）、`auto_increment`（自增）。
- **聚合函数**：`avg()`, `max()`, `min()`, `sum()`, `count()`。
- **查询进阶**：
  - `group by`：分组；`having`：分组后的过滤。
  - `limit`：分页；`order by`：排序。
  - **连接查询**：`inner join`（内连）、`left join`（左连）。

### 3. 高级特性

- **存储过程与函数**：事先编译好的 SQL 集合，提高性能。
- **触发器**：由事件（增删改）自动触发执行。
- **事务 (ACID)**：原子性、一致性、隔离性、持久性。确保成批 SQL 要么全执行，要么全不执行。
- **索引**：类似于目录，提高查询速度。

------

## 📅 Day 12 - 14 网络编程与接口设计

### 1. 网络基础

- **OSI 七层模型**：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
- **TCP/IP 四层**：网络接口层、网络层、传输层、应用层。
- **架构**：C/S（客户端/服务端）与 B/S（浏览器/服务端）。

### 2. Socket 通信

- **TCP**：可靠传输（如传文件）。服务端流程：`socket` -> `bind` -> `listen` -> `accept` -> `recv/send`。
- **UDP**：不可靠传输，实时性高（如直播）。
- **非阻塞与 IO 多路复用**：通过 `setblocking(False)` 和 `select` 模块监控多个客户端，提升效率。
- **粘包**：TCP 优化机制导致多个小包合并。解决方法：发送端先发数据长度。

------

## 📅 Day 15 - 18 并发编程（进程、线程、协程）

### 1. 进程 (Process)

- **定义**：操作系统分配资源的基本单位，数据相互隔离。
- **创建**：`multiprocessing.Process`。
- **守护进程**：`daemon=True`，随父进程结束而结束。
- **互斥锁 (Lock)**：牺牲效率保证数据安全，将并行转为串行。

### 2. 线程 (Thread)

- **定义**：CPU 调度的基本单位，同一进程内的线程共享数据。
- **GIL (全局解释器锁)**：CPython 特有，同一时刻只有一个线程在 CPU 运行。
- **消息队列 (Queue)**：实现进程/线程间通信，先进先出。

### 3. 进程池/线程池

- **优势**：重复利用已创建的进程/线程，减少开闭消耗。
- **回调机制**：`add_done_callback()` 任务完成后自动处理结果。

### 4. 协程 (Coroutine)

- **定义**：单线程下的并发，由开发者控制任务切换，效率极高。
- **实现方式**：
  - `yield` 生成器。
  - `greenlet`。
  - `gevent`（遇 IO 自动切换）。

------

**提示**：在进行 GUI 编程（Tkinter）时，若需阻止窗口关闭，可使用 `root.protocol('WM_DELETE_WINDOW', callback)`。
